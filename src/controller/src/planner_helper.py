#!/usr/bin/env python3

import rospy
import numpy as np
from collections import deque

import os
import subprocess
import csv

from utils.viz_tools import VisualizationTools

from std_msgs.msg import Bool
from geometry_msgs.msg import PoseStamped
# NOTE: currently implemented as a PoseStamped (because it is /move_base_simple/goal), but probably better as a PointStamped
from visualization_msgs.msg import Marker

class PlannerHelper():
	"""
	Call external motion planner using roslaunch arguments, then sequentially feed
	waypoints to controller as robot reaches each one in succession.
	"""

	def __init__(self, position = [0,0,0]):
		self.PLANNER_PATH = rospy.get_param("planner_path")
		if not os.path.isfile(self.PLANNER_PATH):
			rospy.signal_shutdown(f"Planner path: {self.PLANNER_PATH} does not exist!")

		self.MAP_PATH = rospy.get_param("map_path")
		if not os.path.isfile(self.MAP_PATH):
			rospy.signal_shutdown(f"Map path: {self.MAP_PATH} does not exist!")

		self.RESULTS_PATH = rospy.get_param("results_path")
		self.PIXELS_PER_METER = rospy.get_param("pixels_per_meter")

		self.waypoints = deque()
		self.position = np.array(position)

		# Publisher for waypoints
		WAYPOINT_TOPIC = rospy.get_param("waypoint_topic")
		self.waypoint_pub = rospy.Publisher(WAYPOINT_TOPIC, PoseStamped, queue_size=10)

		# Setup flag to know when robot has reached a waypoint
		GOAL_REACHED_FLAG_TOPIC = "/goal_flag_reached"
		self.goal_reached_flag_sub = rospy.Subscriber(GOAL_REACHED_FLAG_TOPIC, Bool, self.goal_reached_callback, queue_size=10)

		# Visualization setup
		self.vt = VisualizationTools()

		rospy.loginfo("Motion Planner helper intialized!")

	def call_motion_planner(self, start, goal, block=True):
		"""
		Call external motion planner to plan from start to goal.
		- start: [x, y, z] 3-vector
		- goal:  [x, y, z] 3-vector
		- block: bool, if the shell call should block execution. If false, will return a Popen object.
		"""
		x0, y0, z0 = start
		x1, y1, z1 = goal
		if block:
			# Block before execution continues
			return subprocess.call([self.PLANNER_PATH, self.MAP_PATH, self.RESULTS_PATH, str(self.PIXELS_PER_METER), "0", "0", "1", str(x0), str(y0), str(z0), str(x1), str(y1), str(z1)])
		else:
			return subprocess.Popen([self.PLANNER_PATH, self.MAP_PATH, self.RESULTS_PATH, str(self.PIXELS_PER_METER), "0", "0", "1", str(x0), str(y0), str(z0), str(x1), str(y1), str(z1)])

	def read_path(self):
		"""
		Reads path.csv generated by motion planner call and stores waypoints in queue
		"""
		if not os.path.isfile(self.RESULTS_PATH + "/path.csv"):
			rospy.logerr("No path.csv found!")
			return False
		with open(self.RESULTS_PATH + "/path.csv", mode='r') as f:
			cf = csv.reader(f)
			for waypoint in cf:
				p = np.array([float(n) for n in waypoint])
				# self.waypoints.append(p) # NOT SURE: been having trouble with very very small dx (0,0,0) -> (0.006,0.1,0)
				
				self.waypoints.append(p - self.position) # Adjust for current offset in world frame

	def waypoints_is_empty(self):
		"""
		Check if waypoints queue is empty.
		"""
		return len(self.waypoints) <= 0

	def publish_waypoint(self):
		"""
		Publish one waypoint from queue.
		"""
		if self.waypoints_is_empty():
			rospy.logerr("Waypoints list is empty!")
			return False
		msg = PoseStamped()
		msg.header.stamp = rospy.Time.now()
		msg.header.frame_id = "/world"

		x, y, z = self.waypoints.pop()
		msg.pose.position.x = float(x)
		msg.pose.position.y = float(y)
		msg.pose.position.z = float(z)

		"""
		NOTE: This isn't setting the orientation of the vectors as expected.
		Ignored when END_ANGLE_THRESHOLD >= 180 deg
		"""
		if not self.waypoints_is_empty():
			# Calculate orientation using next waypoint
			v1 = [float(n) for n in [x, y, z]]
			v2 = [float(n) for n in self.waypoints[-1]]
			rospy.loginfo(f"Crossing {*v1,} and {*v2,}")
			
			v = np.cross(v1, v2)
			w = np.sqrt(np.linalg.norm(v1)**2 * np.linalg.norm(v2)**2) + np.dot(v1, v2)
			q = np.array([v[0], v[1], v[2], w])

			rospy.loginfo("Finished those calculations")

			if any(np.isnan(q)) or np.linalg.norm(q) == 0:
				# Degenerate quaternion, set to identity quaternion
				q = [0, 0, 0, 1]
			else:
				q = q / np.linalg.norm(q) # Normalize quaternion

			rospy.loginfo("Drawing line...")
			
			# Draw line to next waypoint
			self.vt.draw_line(v1, v2)
			rospy.loginfo("Drew line.")
		else:
			q = [0, 0, 0, 1]

		rospy.loginfo(f"Orientation: {q}")
		msg.pose.orientation.x = q[0]
		msg.pose.orientation.y = q[1]
		msg.pose.orientation.z = q[2]
		msg.pose.orientation.w = q[3]

		self.waypoint_pub.publish(msg)
		rospy.loginfo(f"Published waypoint: [{x} {y} {z}]")

	def goal_reached_callback(self, msg):
		"""
		Continue waypoint publishing after each goal is reached.
		"""

		if self.waypoints_is_empty():
			rospy.loginfo("End of path reached!")
		else:
			self.publish_waypoint()



if __name__ == "__main__":
	rospy.init_node("motion_planner_helper")

	START_X = rospy.get_param("start_x")
	START_Y = rospy.get_param("start_y")
	START_Z = rospy.get_param("start_z")
	START = [START_X, START_Y, START_Z]

	GOAL_X = rospy.get_param("goal_x")
	GOAL_Y = rospy.get_param("goal_y")
	GOAL_Z = rospy.get_param("goal_z")
	GOAL = [GOAL_X, GOAL_Y, GOAL_Z]

	# Initialize PlannerHelper
	rospy.loginfo("Trying to initialize motion planner helper...")
	p = PlannerHelper(position = START)
	rospy.loginfo("Motion planner helper initialized.")

	# Call motion planner and log elapsed time
	rospy.loginfo("Calling the motion planner now.")
	sp = p.call_motion_planner(START, GOAL, block=False)
	t = 0
	while sp.poll() is None:
		rospy.loginfo(f"Elapsed time: {t} sec...")
		rospy.sleep(1.0)
		t += 1.0

	rospy.loginfo("Motion planner execution finsihed.")
	p.read_path()
	rospy.loginfo("Path read to system!")

	# Publish first waypoint, then spin
	p.publish_waypoint()
	rospy.spin()
